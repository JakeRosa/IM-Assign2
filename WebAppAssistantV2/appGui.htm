<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Google Calendar Voice Assistant</title>


  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@500&display=swap" rel="stylesheet">

  <style>
    body {
      background-color: #FFFFFF;
      color: #202124;
      /* Cinza escuro Google */
      font-family: 'Roboto', sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
    }

    h1 {
      background-color: #4285F4;
      /* Azul Google */
      color: #FFFFFF;
      margin: 0;
      padding: 20px;
      text-align: center;
      font-size: 28px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      /* Sombra leve */
    }

    .list-container {
      margin: 20px auto;
      width: 80%;
      max-width: 600px;
      background-color: #F1F3F4;
      /* Fundo claro Google */
      border: 2px solid #34A853;
      /* Verde Google */
      padding: 20px;
      font-size: 18px;
      color: #202124;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      display: none;
      /* Esconde inicialmente */
    }

    .list-title {
      font-size: 20px;
      margin-bottom: 10px;
      font-weight: bold;
      text-align: center;
    }

    ul {
      list-style-type: none;
      padding: 0;
    }

    li {
      padding: 8px 0;
      border-bottom: 1px solid #ddd;
    }

    li:last-child {
      border-bottom: none;
    }
  </style>
</head>

<body>
  <h1 style="background-color: #4F5D73; margin: 0;">Google Calendar Voice Assistant</h1>

  <!-- Containers para as listagens -->
  <div id="all-events" class="list-container">
    <div class="list-title">Todos os Eventos</div>
    <ul id="all-events-list"></ul>
  </div>

  <div id="events-of-day" class="list-container">
    <div id="events-of-day-title" class="list-title"></div>
    <ul id="events-of-day-list"></ul>
  </div>

  <div id="holidays" class="list-container">
    <div class="list-title">Feriados Portugueses</div>
    <ul id="holidays-list"></ul>
  </div>

  <div id="birthdays" class="list-container">
    <div class="list-title">Aniversários</div>
    <ul id="birthdays-list"></ul>
  </div>

  <div id="calendar-events" class="list-container">
    <div id="calendar-events-title" class="list-title"></div>
    <ul id="calendar-events-list"></ul>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@latest/dist/svg.min.js"></script>
  <script src="js/mmi.js"></script>
  <script src="js/globals.js"></script>
  <script src="js/jquery-3.6.4.min.js"></script>
  <script src="js/webtoolkit.utf8.js"></script>



  <script type="module">


    var mmiCli_Out_add = "wss://" + host + ":8005/IM/USER1/";
    var mmiCli_Out = null;
    mmiCli_Out = new MMIClientSocket(mmiCli_Out_add + "APP");
    mmiCli_Out.onMessage.on(im1MessageHandler);
    mmiCli_Out.onOpen.on(socketOpenHandler);
    mmiCli_Out.openSocket();


    function socketOpenHandler(event) {
      console.log("---------------openSocketHandler---------------")

      if (mmiCli_Out.socket.readyState !== WebSocket.OPEN) {
        return;
      }
    }

    // let circle = SVG.find('.circle');
    // let square = SVG.find('.square');
    // let triangle = SVG.find('.triangle');

    // circle.animate().attr({ fill: '#ccc' });
    // square.animate().attr({ fill: '#ccc' });
    // triangle.animate().attr({ fill: '#ccc' });

    function hideAllLists() {
      document.querySelectorAll(".list-container").forEach(container => {
        container.style.display = "none";
      });
    }

    let confirmationState = {
      isConfirming: false,
      pendingIntent: null,
      data: null // data to be confirmed
    };

    let createEventState = {
      isAwaitingDetails: false,
      eventName: null,
      eventStartDate: null,
      eventStartTime: null,
      eventEndDate: null,
      eventEndTime: null,
    }

    let addEventToCalendarState = {
      isAwaitingDetails: false,
      calendarName: null,
      eventName: null,
    }

    let updateEventDateState = {
      isAwaitingDetails: false,
      eventName: null,
      date: null,
      newStartDate: null,
    }

    function list_all_events() {
      // make a GET request to the Google Calendar API (localhost:8080/events)
      $.ajax({
        url: "http://localhost:8080/events", // URL do endpoint
        method: "GET",
        success: function (data) {
          if (Array.isArray(data) && data.length > 0) {
            sendToVoice("Ok, aqui tens a lista de todos os eventos no teu calendário:");
            data.reverse().forEach(event => {
              const eventDate = new Date(event.start); // Converte a string ISO para objeto Date
              const options = { weekday: "long", year: "numeric", month: "long", day: "numeric", hour: "2-digit", minute: "2-digit" };
              const formattedDate = eventDate.toLocaleDateString("pt-PT", options); // Formata a data no estilo português
              const message = `Tens o evento ${event.summary} marcado para ${formattedDate}.`;
              sendToVoice(message); // Envia para o assistente de voz
            });
            const items = data.reverse().map(event => {
              const eventDate = new Date(event.start); // Converte a string ISO para objeto Date
              const options = { weekday: "long", year: "numeric", month: "long", day: "numeric", hour: "2-digit", minute: "2-digit" };
              const formattedDate = eventDate.toLocaleDateString("pt-PT", options); // Formata a data no estilo português
              return `<li>${event.summary} - ${formattedDate}</li>`;
            });

            hideAllLists();

            const allEventsList = document.getElementById("all-events-list");
            allEventsList.innerHTML = items.join("");
            document.getElementById("all-events").style.display = "block";
          } else {
            sendToVoice("Não encontrei nenhum evento no teu calendário.");
          }
        },
        error: function (error) {
          console.error("Erro ao buscar eventos:", error);
          sendToVoice("Ocorreu um erro ao listar os eventos. Tenta novamente mais tarde.");
        }
      });
    }

    function create_event(body) {
      $.ajax({
        url: "http://localhost:8080/events",
        method: "POST",
        data: JSON.stringify(body),
        contentType: "application/json",
        success: function (data) {
          if (data.hasOwnProperty("message") && data.message === "Event created") {
            sendToVoice(`Evento "${body.summary}" foi criado com sucesso.`);
          } else {
            sendToVoice("Não foi possível criar o evento. Verifica os detalhes e tenta novamente.");
          }
        },
        error: function (error) {
          console.error("Erro ao criar o evento:", error);
          sendToVoice("Ocorreu um erro ao criar o evento. Tenta novamente mais tarde.");
        }
      });
    }

    function delete_event(body) {
      let event;
      let eventDate;

      // make a DELETE request to the Google Calendar API (localhost:8080/events)
      $.ajax({
        url: "http://localhost:8080/events", // URL do endpoint
        method: "DELETE",
        data: JSON.stringify(body),
        contentType: "application/json",
        success: function (data) {
          if (data.hasOwnProperty("message") && data.message === "Event deleted") {
            event = data.event.summary;
            eventDate = new Date(data.event.start);
            const options = { weekday: "long", year: "numeric", month: "long", day: "numeric", hour: "2-digit", minute: "2-digit" };
            const formattedDate = eventDate.toLocaleDateString("pt-PT", options);
            sendToVoice(`Evento ${event} marcado para ${formattedDate} foi removido com sucesso.`);
          } else {
            sendToVoice("Não encontrei nenhum evento com essas informações.");
          }
        },
        error: function (error) {
          console.error("Erro ao deletar evento:", error);
          sendToVoice("Ocorreu um erro ao remover o evento. Tenta novamente mais tarde.");
        }
      });
    }

    function list_events_of_a_day(eventDate) {
      $.ajax({
        url: `http://localhost:8080/events/day?date=${eventDate}`, // Pass the date as a query parameter
        method: "GET",
        success: function (data) {
          if (Array.isArray(data) && data.length > 0) {
            sendToVoice(`Ok, aqui tens a lista de eventos para o dia ${eventDate}:`);
            data.reverse().forEach(event => {
              const eventDate = new Date(event.start); // Converte a string ISO para objeto Date
              const options = { weekday: "long", year: "numeric", month: "long", day: "numeric", hour: "2-digit", minute: "2-digit" };
              const formattedDate = eventDate.toLocaleDateString("pt-PT", options); // Formata a data no estilo português
              const message = `Tens o evento ${event.summary} marcado para ${formattedDate}.`;
              sendToVoice(message); // Envia para o assistente de voz
            });
            const items = data.reverse().map(event => {
              const eventDate = new Date(event.start); // Converte a string ISO para objeto Date
              const options = { weekday: "long", year: "numeric", month: "long", day: "numeric", hour: "2-digit", minute: "2-digit" };
              const formattedDate = eventDate.toLocaleDateString("pt-PT", options); // Formata a data no estilo português
              return `<li>${event.summary} - ${formattedDate}</li>`;
            });

            hideAllLists();

            const eventsOfDayList = document.getElementById("events-of-day-list");
            eventsOfDayList.innerHTML = items.join("");
            const formattedProvidedDate = new Date(eventDate).toLocaleDateString("pt-PT", { year: "numeric", month: "long", day: "numeric" });
            document.getElementById("events-of-day-title").innerText = `Eventos de ${formattedProvidedDate}`;
            document.getElementById("events-of-day").style.display = "block";
          } else {
            sendToVoice("Não encontrei nenhum evento marcado para esse dia.");
          }
        },
        error: function (error) {
          console.error("Erro ao buscar eventos do dia:", error);
          sendToVoice("Ocorreu um erro ao listar os eventos do dia. Tenta novamente mais tarde.");
        }
      });
    }

    function list_holidays() {
      // make a GET request to the Google Calendar API (localhost:8080/holidays)
      $.ajax({
        url: "http://localhost:8080/holidays", // URL do endpoint
        method: "GET",
        success: function (data) {
          if (Array.isArray(data) && data.length > 0) {
            sendToVoice("Aqui estão os feriados e outras comemorações que encontrei");
            data.reverse().forEach(holiday => {
              const holidayDate = new Date(holiday.start); // Converte a string ISO para objeto Date
              const options = { weekday: "long", year: "numeric", month: "long", day: "numeric" };
              const formattedDate = holidayDate.toLocaleDateString("pt-PT", options); // Formata a data no estilo português
              const message = `${holiday.summary}, será na ${formattedDate}.`;
              sendToVoice(message); // Envia para o assistente de voz
            });
            const items = data.reverse().map(holiday => {
              const holidayDate = new Date(holiday.start); // Converte a string ISO para objeto Date
              const options = { weekday: "long", year: "numeric", month: "long", day: "numeric" };
              const formattedDate = holidayDate.toLocaleDateString("pt-PT", options); // Formata a data no estilo português
              return `<li>${holiday.summary} - ${formattedDate}</li>`;
            });

            hideAllLists();

            const holidaysList = document.getElementById("holidays-list");
            holidaysList.innerHTML = items.join("");
            document.getElementById("holidays").style.display = "block";
          } else {
            sendToVoice("Não encontrei nenhum feriado ou comemoração no calendário.");
          }
        },
        error: function (error) {
          console.error("Erro ao buscar feriados:", error);
          sendToVoice("Ocorreu um erro ao listar os feriados e comemorações. Tenta novamente mais tarde.");
        }
      });
    }

    function update_event_date(body) {
      const eventName = body.summary;
      const eventDate = body.date;
      const newStartDate = body.new_start;
      const newStartHour = body.new_start_hour;

      console.log(body);

      // Fazer uma solicitação PUT para atualizar a data do evento
      $.ajax({
        url: "http://localhost:8080/events/move", // URL do endpoint
        method: "PUT",
        data: JSON.stringify(body),
        contentType: "application/json",
        success: function (data) {
          if (data.hasOwnProperty("message") && data.message === "Event moved") {
            let formattedNewStartDate = new Date(newStartDate).toLocaleDateString("pt-PT", { year: "numeric", month: "long", day: "numeric", hour: "2-digit", minute: "2-digit" });
            sendToVoice(`A data do evento "${eventName}" foi atualizada com sucesso para ${formattedNewStartDate}.`);
          } else if (data.hasOwnProperty("message") && data.message === "No matching event found.") {
            sendToVoice(`Não encontrei um evento chamado "${eventName}" na data ${eventDate}. Verifica as informações e tenta novamente.`);
          } else {
            sendToVoice("Não foi possível atualizar a data do evento. Tenta novamente mais tarde.");
          }
        },
        error: function (error) {
          console.error("Erro ao atualizar a data do evento:", error);
          sendToVoice("Ocorreu um erro ao atualizar a data do evento. Tenta novamente mais tarde.");
        }
      });
    }

    function list_birthdays() {
      // make a GET request to the Google Calendar API (localhost:8080/birthdays)
      $.ajax({
        url: "http://localhost:8080/birthdays", // URL do endpoint
        method: "GET",
        success: function (data) {
          if (Array.isArray(data) && data.length > 0) {
            data.reverse().forEach(birthday => {
              const birthdayDate = new Date(birthday.start); // Converte a string ISO para objeto Date
              const options = { weekday: "long", year: "numeric", month: "long", day: "numeric" };
              const formattedDate = birthdayDate.toLocaleDateString("pt-PT", options); // Formata a data no estilo português
              const message = `Tens o aniversário ${birthday.summary}, na ${formattedDate}.`;
              sendToVoice(message); // Envia para o assistente de voz
            });
            const items = data.reverse().map(birthday => {
              const birthdayDate = new Date(birthday.start); // Converte a string ISO para objeto Date
              const options = { weekday: "long", year: "numeric", month: "long", day: "numeric" };
              const formattedDate = birthdayDate.toLocaleDateString("pt-PT", options); // Formata a data no estilo português
              return `<li>${birthday.summary} - ${formattedDate}</li>`;
            });

            hideAllLists();

            const birthdaysList = document.getElementById("birthdays-list");
            birthdaysList.innerHTML = items.join("");
            document.getElementById("birthdays").style.display = "block";
          } else {
            sendToVoice("Não encontrei nenhum aniversário.");
          }
        },
        error: function (error) {
          console.error("Erro ao buscar aniversários:", error);
          sendToVoice("Ocorreu um erro ao listar os aniversários. Tenta novamente mais tarde.");
        }
      });
    }

    function create_calendar(calendarName) {
      let body = {
        summary: calendarName
      }

      // make a POST request to the Google Calendar API (localhost:8080/calendars)
      $.ajax({
        url: "http://localhost:8080/calendars", // URL do endpoint
        method: "POST",
        data: JSON.stringify(body),
        contentType: "application/json",
        success: function (data) {
          if (data.hasOwnProperty("message") && data.message === "Calendar created") {
            sendToVoice(`Calendário ${calendarName} criado com sucesso.`);
          } else {
            sendToVoice("Não foi possível criar o calendário. Tenta novamente mais tarde.");
          }
        },
        error: function (error) {
          console.error("Erro ao criar calendário:", error);
          sendToVoice("Ocorreu um erro ao criar o calendário. Tenta novamente mais tarde.");
        }
      });
    }

    function delete_calendar(calendarName) {
      let body = {
        summary: calendarName
      }

      // make a DELETE request to the Google Calendar API (localhost:8080/calendars)
      $.ajax({
        url: "http://localhost:8080/calendars", // URL do endpoint
        method: "DELETE",
        data: JSON.stringify(body),
        contentType: "application/json",
        success: function (data) {
          if (data.hasOwnProperty("message") && data.message === "Calendar deleted") {
            sendToVoice(`Calendário ${calendarName} removido com sucesso.`);
          } else {
            sendToVoice("Não foi possível remover o calendário. Tenta novamente mais tarde.");
          }
        },
        error: function (error) {
          console.error("Erro ao deletar calendário:", error);
          sendToVoice("Ocorreu um erro ao remover o calendário. Tenta novamente mais tarde.");
        }
      });
    }

    function move_event_to_calendar(body) {
      const eventName = body.summary;
      const eventDate = body.date;
      const newCalendar = body.new_calendar_summary;

      // Fazer uma solicitação PUT para mover o evento para outro calendário
      $.ajax({
        url: "http://localhost:8080/events/move-to-calendar", // URL do endpoint
        method: "PUT",
        data: JSON.stringify(body),
        contentType: "application/json",
        success: function (data) {
          if (data.hasOwnProperty("message") && data.message === "Event moved to new calendar") {
            sendToVoice(`Evento "${eventName}" foi movido para o calendário "${newCalendar}" com sucesso.`);
          } else if (data.hasOwnProperty("message") && data.message === "No matching event found.") {
            sendToVoice(`Não encontrei um evento chamado "${eventName}" na data ${eventDate}. Verifica as informações e tenta novamente.`);
          } else if (data.hasOwnProperty("message") && data.message === "No matching calendar found.") {
            sendToVoice(`Não encontrei um calendário chamado "${newCalendar}". Verifica o nome do calendário e tenta novamente.`);
          } else {
            sendToVoice("Não foi possível mover o evento. Tenta novamente mais tarde.");
          }
        },
        error: function (error) {
          console.error("Erro ao mover evento:", error);
          sendToVoice("Ocorreu um erro ao mover o evento para outro calendário. Tenta novamente mais tarde.");
        }
      });
    }

    function list_events_in_calendar(calendarName) {
      // make a GET request to the Google Calendar API (localhost:8080/events/calendar)
      $.ajax({
        url: `http://localhost:8080/events/calendar?calendar_summary=${calendarName}`, // Pass the calendar name as a query parameter
        method: "GET",
        success: function (data) {
          if (Array.isArray(data) && data.length > 0) {
            sendToVoice(`Aqui estão os eventos no calendário ${calendarName}:`);
            data.reverse().forEach(event => {
              const eventDate = new Date(event.start); // Converte a string ISO para objeto Date
              const options = { weekday: "long", year: "numeric", month: "long", day: "numeric", hour: "2-digit", minute: "2-digit" };
              const formattedDate = eventDate.toLocaleDateString("pt-PT", options); // Formata a data no estilo português
              const message = `Tens o evento ${event.summary} marcado para ${formattedDate}.`;
              sendToVoice(message); // Envia para o assistente de voz
            });
            const items = data.reverse().map(event => {
              const eventDate = new Date(event.start); // Converte a string ISO para objeto Date
              const options = { weekday: "long", year: "numeric", month: "long", day: "numeric", hour: "2-digit", minute: "2-digit" };
              const formattedDate = eventDate.toLocaleDateString("pt-PT", options); // Formata a data no estilo português
              return `<li>${event.summary} - ${formattedDate}</li>`;
            });

            hideAllLists();

            const calendarEventsList = document.getElementById("calendar-events-list");
            calendarEventsList.innerHTML = items.join("");
            document.getElementById("calendar-events-title").innerText = `Eventos no calendário ${calendarName}`;
            document.getElementById("calendar-events").style.display = "block";
          } else {
            sendToVoice(`Não encontrei nenhum evento no calendário ${calendarName}.`);
          }
        },
        error: function (error) {
          console.error("Erro ao buscar eventos do calendário:", error);
          sendToVoice(`Ocorreu um erro ao listar os eventos do calendário ${calendarName}. Tente novamente mais tarde.`);
        }
      });
    }

    function im1MessageHandler(data) {

      console.log("--------------im1MessageHandler---------------");

      if (data != null && data != "RENEW" && data != "OK") {
        console.log(data);
        var content = $(data).find("emma\\:interpretation").first().text().trim();
        if (typeof content == 'string') {
          try {
            // Try to parse XML
            console.log(content);

            //$("#response").html(content);
            //$("#response").addClass("container");
            //$("#response").addClass("responseText");

            let c = JSON.parse(content);

            if (c.hasOwnProperty("nlu") && c.nlu.confidence < 0.45) {
              sendToVoice("Não percebi o que quiseste dizer. Podes repetir?");
            }

            if (c.hasOwnProperty("nlu") && c.nlu.intent == "affirm" && confirmationState.isConfirming) {
              if (confirmationState.pendingIntent === "help") {
                sendToVoice("Aqui está a lista de todos os comandos que podes usar: Se queres listar todos os eventos diz: Lista todos os eventos; Se queres criar um evento diz: Quero criar um novo evento")
              } else if (confirmationState.pendingIntent === "list_all_events") {
                list_all_events();
              } else if (confirmationState.pendingIntent === "create_event") {
                createEventState.isAwaitingDetails = true;
                sendToVoice("Qual vai ser o nome do evento?");
              } else if (confirmationState.pendingIntent === "delete_event") {
                let body = {
                  summary: confirmationState.data.event,
                  date: confirmationState.data.date
                };
                delete_event(body);
              } else if (confirmationState.pendingIntent === "list_events_of_a_day") {
                list_events_of_a_day(confirmationState.data.date);
              } else if (confirmationState.pendingIntent === "list_holidays") {
                list_holidays();
              } else if (confirmationState.pendingIntent === "list_birthdays") {
                list_birthdays();
              } else if (confirmationState.pendingIntent === "create_calendar") {
                create_calendar(confirmationState.data.calendar);
              } else if (confirmationState.pendingIntent === "delete_calendar") {
                delete_calendar(confirmationState.data.calendar);
              } else if (confirmationState.pendingIntent === "list_events_in_calendar") {
                list_events_in_calendar(confirmationState.data.calendar);
              } else if (confirmationState.pendingIntent === "add_event_to_calendar") {
                addEventToCalendarState.isAwaitingDetails = true;
                addEventToCalendarState.calendarName = confirmationState.data.calendar;
                sendToVoice(`Qual é o nome do evento que queres mover?`);
              } else if (confirmationState.pendingIntent === "provide_event_name") {
                if (addEventToCalendarState.isAwaitingDetails) {
                  addEventToCalendarState.eventName = confirmationState.data.event;
                  sendToVoice(`Qual é a data do evento ${addEventToCalendarState.eventName}?`);
                } else if (updateEventDateState.isAwaitingDetails) {
                  updateEventDateState.eventName = confirmationState.data.event;
                  sendToVoice(`Qual é a data atual do evento ${updateEventDateState.eventName}?`);
                } else if (createEventState.isAwaitingDetails) {
                  createEventState.eventName = confirmationState.data.event;
                  sendToVoice(`Qual vai ser a data de início do evento ${createEventState.eventName}?`);
                }
              } else if (confirmationState.pendingIntent === "provide_date") {
                if (addEventToCalendarState.isAwaitingDetails) {
                  let body = {
                    summary: addEventToCalendarState.eventName,
                    date: confirmationState.data.date,
                    new_calendar_summary: addEventToCalendarState.calendarName,
                  };
                  move_event_to_calendar(body);

                  addEventToCalendarState.isAwaitingDetails = false;
                  addEventToCalendarState.calendarName = null;
                  addEventToCalendarState.eventName = null;
                } else if (updateEventDateState.isAwaitingDetails && updateEventDateState.date == null) {
                  updateEventDateState.date = confirmationState.data.date;
                  sendToVoice(`Qual será a nova data do evento ${updateEventDateState.eventName}?`);
                } else if (updateEventDateState.isAwaitingDetails && updateEventDateState.date != null && updateEventDateState.newStartDate == null) {
                  updateEventDateState.newStartDate = confirmationState.data.date;
                  sendToVoice(`Qual será a nova hora do evento ${updateEventDateState.eventName}?`);
                } else if (createEventState.isAwaitingDetails && createEventState.eventStartDate == null) {
                  createEventState.eventStartDate = confirmationState.data.date;
                  sendToVoice(`Qual vai ser a hora de início do evento ${createEventState.eventName}?`);
                } else if (createEventState.isAwaitingDetails && createEventState.eventEndDate == null) {
                  createEventState.eventEndDate = confirmationState.data.date;
                  sendToVoice(`Qual vai ser a hora de fim do evento ${createEventState.eventName}?`);
                }
              } else if (confirmationState.pendingIntent === "update_event_date") {
                updateEventDateState.isAwaitingDetails = true;
                sendToVoice(`Qual é o nome do evento que queres atualizar a data?`);
              } else if (confirmationState.pendingIntent === "provide_time") {
                if (updateEventDateState.isAwaitingDetails && updateEventDateState.date != null && updateEventDateState.newStartDate != null) {
                  let isoTimestamp = `${updateEventDateState.newStartDate}T${confirmationState.data.time}:00+00:00`;
                  let body = {
                    summary: updateEventDateState.eventName,
                    date: updateEventDateState.date,
                    new_start: isoTimestamp
                  };

                  update_event_date(body);

                  updateEventDateState.isAwaitingDetails = false;
                  updateEventDateState.eventName = null;
                  updateEventDateState.date = null;
                  updateEventDateState.newStartDate = null;
                } else if (createEventState.isAwaitingDetails && createEventState.eventStartDate != null && createEventState.eventStartTime == null) {
                  createEventState.eventStartTime = confirmationState.data.time;
                  sendToVoice(`Qual vai ser a data de fim do evento ${createEventState.eventName}?`);
                } else if (createEventState.isAwaitingDetails && createEventState.eventEndDate != null && createEventState.eventEndTime == null) {
                  createEventState.eventEndTime = confirmationState.data.time;
                  let isoStartTimestamp = `${createEventState.eventStartDate}T${createEventState.eventStartTime}:00+00:00`;
                  let isoEndTimestamp = `${createEventState.eventEndDate}T${createEventState.eventEndTime}:00+00:00`;
                  let body = {
                    summary: createEventState.eventName,
                    start: isoStartTimestamp,
                    end: isoEndTimestamp
                  };

                  create_event(body);

                  createEventState.isAwaitingDetails = false;
                  createEventState.eventName = null;
                  createEventState.eventStartDate = null;
                  createEventState.eventStartTime = null;
                  createEventState.eventEndDate = null;
                  createEventState.eventEndTime = null;
                }
              }
              confirmationState.isConfirming = false;
              confirmationState.pendingIntent = null;
              confirmationState.data = null;
            }

            if (c.hasOwnProperty("nlu") && c.nlu.intent == "deny" && confirmationState.isConfirming) {
              sendToVoice("Operação cancelada.");
              confirmationState.isConfirming = false;
              confirmationState.pendingIntent = null;
              confirmationState.data = null;
            }

            if (c.hasOwnProperty("nlu") && c.nlu.intent == "provide_event_name" && c.nlu.name_confidence >= 0.8) {
              if (addEventToCalendarState.isAwaitingDetails) {
                addEventToCalendarState.eventName = c.nlu.event;
                sendToVoice(`Qual é a data do evento ${addEventToCalendarState.eventName}?`);
              } else if (updateEventDateState.isAwaitingDetails) {
                updateEventDateState.eventName = c.nlu.event;
                sendToVoice(`Qual é a data atual do evento ${updateEventDateState.eventName}?`);
              } else if (createEventState.isAwaitingDetails) {
                createEventState.eventName = c.nlu.event;
                sendToVoice(`Qual vai ser a data de início do evento ${createEventState.eventName}?`);
              }
            } else if (c.hasOwnProperty("nlu") && c.nlu.intent == "provide_event_name" && (c.nlu.name_confidence >= 0.45 && c.nlu.name_confidence < 0.8)) {
              if (addEventToCalendarState.isAwaitingDetails || updateEventDateState.isAwaitingDetails) {
                sendToVoice(`Percebi que o evento chama-se ${c.nlu.event}. Está correto?`);
              } else if (createEventState.isAwaitingDetails) {
                sendToVoice(`Percebi que o nome do evento será ${c.nlu.event}. Está correto?`);
              }
              confirmationState.isConfirming = true;
              confirmationState.pendingIntent = "provide_event_name";
              confirmationState.data = c.nlu;
            }

            if (c.hasOwnProperty("nlu") && c.nlu.intent == "provide_date" && c.nlu.confidence >= 0.8) {
              if (addEventToCalendarState.isAwaitingDetails) {
                let body = {
                  summary: addEventToCalendarState.eventName,
                  date: c.nlu.date,
                  new_calendar_summary: addEventToCalendarState.calendarName,
                };
                move_event_to_calendar(body);

                addEventToCalendarState.isAwaitingDetails = false;
                addEventToCalendarState.calendarName = null;
                addEventToCalendarState.eventName = null;
              } else if (updateEventDateState.isAwaitingDetails && updateEventDateState.date == null) {
                updateEventDateState.date = c.nlu.date;
                sendToVoice(`Qual será a nova data do evento ${updateEventDateState.eventName}?`);
              } else if (updateEventDateState.isAwaitingDetails && updateEventDateState.date != null && updateEventDateState.newStartDate == null) {
                updateEventDateState.newStartDate = c.nlu.date;
                sendToVoice(`Qual será a nova hora do evento ${updateEventDateState.eventName}?`);
              } else if (createEventState.isAwaitingDetails && createEventState.eventStartDate == null) {
                createEventState.eventStartDate = c.nlu.date;
                sendToVoice(`Qual vai ser a hora de início do evento ${createEventState.eventName}?`);
              } else if (createEventState.isAwaitingDetails && createEventState.eventEndDate == null) {
                createEventState.eventEndDate = c.nlu.date;
                sendToVoice(`Qual vai ser a hora de fim do evento ${createEventState.eventName}?`);
              }
            } else if (c.hasOwnProperty("nlu") && c.nlu.intent == "provide_date" && (c.nlu.confidence >= 0.45 && c.nlu.confidence < 0.8)) {
              let formattedProvidedDate = new Date(c.nlu.date).toLocaleDateString("pt-PT", { year: "numeric", month: "long", day: "numeric" });
              if (addEventToCalendarState.isAwaitingDetails) {
                sendToVoice(`Percebi que a data do evento é ${formattedProvidedDate}. Está correta?`);
              } else if (updateEventDateState.isAwaitingDetails && updateEventDateState.date == null) {
                sendToVoice(`Percebi que a data atual do evento é ${formattedProvidedDate}. Está correta?`);
              } else if (updateEventDateState.isAwaitingDetails && updateEventDateState.date != null && updateEventDateState.newStartDate == null) {
                sendToVoice(`Percebi que a nova data do evento será ${formattedProvidedDate}. Está correta?`);
              } else if (createEventState.isAwaitingDetails && createEventState.eventStartDate == null) {
                sendToVoice(`Percebi que a data de início do evento será ${formattedProvidedDate}. Está correta?`);
              } else if (createEventState.isAwaitingDetails && createEventState.eventEndDate == null) {
                sendToVoice(`Percebi que a data de fim do evento será ${formattedProvidedDate}. Está correta?`);
              }
              confirmationState.isConfirming = true;
              confirmationState.pendingIntent = "provide_date";
              confirmationState.data = c.nlu;
            }

            if (c.hasOwnProperty("nlu") && c.nlu.intent == "provide_time" && c.nlu.confidence >= 0.8) {
              if (updateEventDateState.isAwaitingDetails && updateEventDateState.date != null && updateEventDateState.newStartDate != null) {
                let isoTimestamp = `${updateEventDateState.newStartDate}T${c.nlu.time}:00+00:00`;
                let body = {
                  summary: updateEventDateState.eventName,
                  date: updateEventDateState.date,
                  new_start: isoTimestamp
                };

                update_event_date(body);

                updateEventDateState.isAwaitingDetails = false;
                updateEventDateState.eventName = null;
                updateEventDateState.date = null;
                updateEventDateState.newStartDate = null;
              } else if (createEventState.isAwaitingDetails && createEventState.eventStartDate != null && createEventState.eventStartTime == null) {
                createEventState.eventStartTime = c.nlu.time;
                sendToVoice(`Qual vai ser a data de fim do evento ${createEventState.eventName}?`);
              } else if (createEventState.isAwaitingDetails && createEventState.eventEndDate != null && createEventState.eventEndTime == null) {
                createEventState.eventEndTime = c.nlu.time;
                let isoStartTimestamp = `${createEventState.eventStartDate}T${createEventState.eventStartTime}:00+00:00`;
                let isoEndTimestamp = `${createEventState.eventEndDate}T${createEventState.eventEndTime}:00+00:00`;
                let body = {
                  summary: createEventState.eventName,
                  start: isoStartTimestamp,
                  end: isoEndTimestamp
                };

                create_event(body);

                createEventState.isAwaitingDetails = false;
                createEventState.eventName = null;
                createEventState.eventStartDate = null;
                createEventState.eventStartTime = null;
                createEventState.eventEndDate = null;
                createEventState.eventEndTime = null;
              }
            } else if (c.hasOwnProperty("nlu") && c.nlu.intent == "provide_time" && (c.nlu.confidence >= 0.45 && c.nlu.confidence < 0.8)) {
              if (updateEventDateState.isAwaitingDetails && updateEventDateState.date != null && updateEventDateState.newStartDate != null) {
                sendToVoice(`Percebi que a nova hora do evento será ${c.nlu.time}. Está correta?`);
              } else if (createEventState.isAwaitingDetails && createEventState.eventStartDate != null && createEventState.eventStartTime == null) {
                sendToVoice(`Percebi que a hora de início do evento será ${c.nlu.time}. Está correta?`);
              } else if (createEventState.isAwaitingDetails && createEventState.eventEndDate != null && createEventState.eventEndTime == null) {
                sendToVoice(`Percebi que a hora de fim do evento será ${c.nlu.time}. Está correta?`);
              }
              confirmationState.isConfirming = true;
              confirmationState.pendingIntent = "provide_time";
              confirmationState.data = c.nlu;
            }

            if (c.hasOwnProperty("nlu") && c.nlu.intent == "help" && c.nlu.confidence >= 0.8) {
              sendToVoice("Aqui está a lista de todos os comandos que podes usar: Se queres listar todos os eventos diz: Lista todos os eventos; Se queres criar um evento diz: Quero criar um novo evento")
            } else if (c.hasOwnProperty("nlu") && c.nlu.intent == "help" && (c.nlu.confidence >= 0.45 && c.nlu.confidence < 0.8)) {
              sendToVoice("Percebi que precisas de ajuda. Está correto?");
              confirmationState.isConfirming = true;
              confirmationState.pendingIntent = "help";
              confirmationState.data = null;
            }

            if (c.hasOwnProperty("nlu") && c.nlu.intent == "list_all_events" && c.nlu.confidence >= 0.8) {
              list_all_events();
            } else if (c.hasOwnProperty("nlu") && c.nlu.intent == "list_all_events" && (c.nlu.confidence >= 0.45 && c.nlu.confidence < 0.8)) {
              sendToVoice("Percebi que queres listar todos os eventos do teu calendário. Está correto?");
              confirmationState.isConfirming = true;
              confirmationState.pendingIntent = "list_all_events";
              confirmationState.data = null;
            }

            if (c.hasOwnProperty("nlu") && c.nlu.intent == "create_event" && c.nlu.confidence >= 0.8) {
              createEventState.isAwaitingDetails = true;
              sendToVoice("Qual vai ser o nome do evento?");
            } else if (c.hasOwnProperty("nlu") && c.nlu.intent == "create_event" && (c.nlu.confidence >= 0.45 && c.nlu.confidence < 0.8)) {
              sendToVoice("Percebi que queres criar um novo evento. Está correto?");
              confirmationState.isConfirming = true;
              confirmationState.pendingIntent = "create_event";
              confirmationState.data = c.nlu;
            }

            if (c.hasOwnProperty("nlu") && c.nlu.intent == "delete_event") {
              let formattedProvidedDate = new Date(c.nlu.date).toLocaleDateString("pt-PT", { year: "numeric", month: "long", day: "numeric" });
              sendToVoice(`Percebi que queres apagar o evento ${c.nlu.event} do dia ${formattedProvidedDate}. Está correto?`);
              confirmationState.isConfirming = true;
              confirmationState.pendingIntent = "delete_event";
              confirmationState.data = c.nlu;
            }

            if (c.hasOwnProperty("nlu") && c.nlu.intent == "list_events_of_a_day" && c.nlu.confidence >= 0.8) {
              let eventDate = c.nlu.date; // Date in "YYYY-MM-DD" format

              list_events_of_a_day(eventDate);
            } else if (c.hasOwnProperty("nlu") && c.nlu.intent == "list_events_of_a_day" && (c.nlu.confidence >= 0.45 && c.nlu.confidence < 0.8)) {
              let formattedProvidedDate = new Date(c.nlu.date).toLocaleDateString("pt-PT", { year: "numeric", month: "long", day: "numeric" });
              sendToVoice(`Percebi que queres listar os eventos do dia ${formattedProvidedDate}. Está correto?`);
              confirmationState.isConfirming = true;
              confirmationState.pendingIntent = "list_events_of_a_day";
              confirmationState.data = c.nlu;
            }

            if (c.hasOwnProperty("nlu") && c.nlu.intent == "list_holidays" && c.nlu.confidence >= 0.8) {
              list_holidays();
            } else if (c.hasOwnProperty("nlu") && c.nlu.intent == "list_holidays" && (c.nlu.confidence >= 0.45 && c.nlu.confidence < 0.8)) {
              sendToVoice("Percebi que queres listar os feriados portugueses e outras comemorações. Está correto?");
              confirmationState.isConfirming = true;
              confirmationState.pendingIntent = "list_holidays";
              confirmationState.data = null;
            }

            if (c.hasOwnProperty("nlu") && c.nlu.intent == "update_event_date" && c.nlu.confidence >= 0.8) {
              updateEventDateState.isAwaitingDetails = true;
              sendToVoice(`Qual é o nome do evento que queres atualizar a data?`);
            } else if (c.hasOwnProperty("nlu") && c.nlu.intent == "update_event_date" && (c.nlu.confidence >= 0.45 && c.nlu.confidence < 0.8)) {
              sendToVoice(`Percebi que queres atualizar a data de um evento. Está correto?`);
              confirmationState.isConfirming = true;
              confirmationState.pendingIntent = "update_event_date";
              confirmationState.data = c.nlu;
            }

            if (c.hasOwnProperty("nlu") && c.nlu.intent == "list_birthdays" && c.nlu.confidence >= 0.8) {
              list_birthdays();
            } else if (c.hasOwnProperty("nlu") && c.nlu.intent == "list_birthdays" && (c.nlu.confidence >= 0.45 && c.nlu.confidence < 0.8)) {
              sendToVoice("Percebi que queres listar os aniversários. Está correto?");
              confirmationState.isConfirming = true;
              confirmationState.pendingIntent = "list_birthdays";
              confirmationState.data = null;
            }

            if (c.hasOwnProperty("nlu") && c.nlu.intent == "create_calendar" && c.nlu.confidence >= 0.8) {
              let calendarName = c.nlu.calendar;

              create_calendar(calendarName);
            } else if (c.hasOwnProperty("nlu") && c.nlu.intent == "create_calendar" && (c.nlu.confidence >= 0.45 && c.nlu.confidence < 0.8)) {
              sendToVoice("Percebi que queres criar um novo calendário. Está correto?");
              confirmationState.isConfirming = true;
              confirmationState.pendingIntent = "create_calendar";
              confirmationState.data = c.nlu;
            }

            if (c.hasOwnProperty("nlu") && c.nlu.intent == "delete_calendar") {
              sendToVoice(`Percebi que queres apagar o calendário ${c.nlu.calendar}. Está correto?`);
              confirmationState.isConfirming = true;
              confirmationState.pendingIntent = "delete_calendar";
              confirmationState.data = c.nlu;
            }

            if (c.hasOwnProperty("nlu") && c.nlu.intent == "add_event_to_calendar" && c.nlu.confidence >= 0.8) {
              addEventToCalendarState.isAwaitingDetails = true;
              addEventToCalendarState.calendarName = c.nlu.calendar;
              sendToVoice(`Qual é o nome do evento que queres mover?`);
            } else if (c.hasOwnProperty("nlu") && c.nlu.intent == "add_event_to_calendar" && (c.nlu.confidence >= 0.45 && c.nlu.confidence < 0.8)) {
              sendToVoice(`Percebi que queres mover um evento para o calendário ${c.nlu.calendar}. Está correto?`);
              confirmationState.isConfirming = true;
              confirmationState.pendingIntent = "add_event_to_calendar";
              confirmationState.data = c.nlu;
            }

            if (c.hasOwnProperty("nlu") && c.nlu.intent == "list_events_in_calendar" && c.nlu.confidence >= 0.8) {
              let calendarName = c.nlu.calendar;

              list_events_in_calendar(calendarName);
            }

            /*setTimeout(function(){
              $("#response").html("");
              $("#response").removeClass("container");
              $("#response").removeClass("responseText");
            }, 3000);
            */
          }
          catch (e) { console.log(e); }

        }
      }
    }


    /////

    var mmiCli_1 = null;
    mmiCli_1 = new MMIClient(null, "https://" + host + ":8000/IM/USER1/APPSPEECH");

    // circle.on('click', function () {
    //   console.log("circulo");
    //   sendToVoice("circulo");
    // })

    // square.on('click', function () {
    //   console.log("quadrado");
    //   sendToVoice("quadradoç");
    // })

    // triangle.on('click', function () {
    //   console.log("triangulo");
    //   sendToVoice("triangulo");
    // })

    function sendToVoice(texto) {
      //let speak = "&lt;speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.w3.org/2001/10/synthesis http://www.w3.org/TR/speech-synthesis/synthesis.xsd\" xml:lang=\"pt-PT\"&gt;&lt;p&gt;" + "quadrado" + "&lt;/p&gt;&lt;/speak&gt";
      let speak = "<speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.w3.org/2001/10/synthesis http://www.w3.org/TR/speech-synthesis/synthesis.xsd\" xml:lang=\"pt-PT\"><p>" + texto + "</p></speak>";
      var result = speak;
      mmiCli_1.sendToIM(new LifeCycleEvent("APPSPEECH", "IM", "text-1", "ctx-1").
        doStartRequest(new EMMA("text-", "text", "command", 1, 0).
          setValue(JSON.stringify(result))));
    }




    /////////////////////////////////////////

  </script>
</body>

</html>